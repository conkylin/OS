# SLUB内存分配器算法设计文档

## 1. 算法概述

SLUB（Simple List of Unordered Blocks）分配器是一种高效的内核内存管理算法，专门用于管理小块内存的分配。本实现基于Linux内核SLUB分配器的设计理念，针对操作系统内核中的小对象分配需求进行了优化。SLUB分配器通过在物理页面内部构建对象缓存池，显著提高了小内存分配的效率和性能[2](@ref)。

**核心设计特点**：
- 基于对象缓存的内存管理机制
- 每个CPU本地缓存减少锁竞争
- 自动内存回收和页面释放
- 支持多种对象大小的分级缓存
- 完整的内存分配追踪和调试支持

## 2. 系统架构设计

### 2.1 核心数据结构

系统采用分层缓存结构管理内存：

**全局缓存数组**：


static struct slub_cache slub_caches[SLUB_CACHE_NUM];


管理不同大小的对象缓存，预定义对象大小为8B到2048B的2的幂次方[2](@ref)。

**缓存结构体**：


struct slub_cache {

size_t size;                    // 对象大小

int align;                      // 对齐要求

int objects_per_page;           // 每页对象数量

list_entry_t partial;          // 部分空闲页面链表

list_entry_t full;             // 完全占用页面链表

int nr_partial, nr_full;       // 页面统计

int total_objects, used_objects; // 对象统计

const char *name;              // 缓存名称

};


**页面管理结构**：


struct slub_page {

struct slub_cache *cache;      // 所属缓存

struct Page *page;            // 对应的物理页

int inuse;                    // 已使用对象数

int objects;                  // 总对象数

void *freelist;               // 空闲对象链表

list_entry_t page_link;       // 页面链表节点

};


### 2.2 内存管理层次

系统采用三级管理结构：
1. **页分配器层**：基于伙伴系统的物理页面分配
2. **缓存管理层**：按对象大小分类的缓存池管理  
3. **对象分配层**：单个内存对象的分配和释放

## 3. 核心算法详细设计

### 3.1 初始化算法

**系统初始化**：


void slub_init(void)


初始化流程包括：
1. 检查初始化状态避免重复初始化
2. 初始化全局空闲页面链表
3. 为每个预定义对象大小创建缓存结构
4. 设置缓存参数（对象大小、对齐、每页对象数）
5. 初始化部分空闲和完全占用链表[2](@ref)

**缓存创建**：
为每个对象大小创建独立的缓存实例，计算每页可容纳的对象数量，优化内存利用率。

### 3.2 内存分配算法

**分配入口函数**：


void *slub_alloc(size_t size)


分配流程决策树：
- 大对象（>SLUB_MAX_SIZE）：直接使用页分配器
- 小对象：通过对应缓存分配
- 首次分配：触发系统初始化

**缓存选择算法**：


struct slub_cache *slub_get_cache(size_t size)


采用最小适配策略，找到第一个大于等于请求大小的缓存，保证内存使用效率[1](@ref)。

**对象分配核心逻辑**：


static void *slub_alloc_object(struct slub_cache *cache)


1. 优先从部分空闲页面分配
2. 无可用页面时分配新页面
3. 从页面freelist获取空闲对象
4. 更新页面使用状态统计
5. 页面状态变化时调整链表位置

### 3.3 内存释放算法

**释放入口函数**：


void slub_free(void *ptr)


释放流程：
1. 通过地址定位所属页面和缓存
2. 验证指针有效性
3. 调用对象释放逻辑
4. 大内存直接释放物理页面

**对象释放核心逻辑**：


static void slub_free_object(struct slub_cache *cache, void *ptr)


1. 将对象重新加入页面freelist
2. 更新页面使用计数
3. 调整页面在链表中的位置：
   - 从满链表移到部分空闲链表
   - 完全空闲页面考虑释放
4. 更新缓存统计信息

### 3.4 页面管理机制

**页面分配**：


static struct slub_page *slub_alloc_page_internal(struct slub_cache *cache)


1. 从页分配器获取物理页面
2. 在页面开头存储slub_page元数据
3. 初始化对象freelist链表
4. 将页面加入部分空闲链表

**页面释放条件**：
- 页面完全空闲（inuse == 0）
- 系统中有多个部分空闲页面（避免频繁分配释放）
- 缓存中存在足够的空闲页面

## 4. 关键技术特性

### 4.1 空闲对象管理

采用嵌入式freelist设计，利用空闲对象内存存储下一个空闲对象的指针，实现零额外内存开销的空闲链表管理[2](@ref)。

**freelist构建算法**：


// 在页面内构建对象链表

void *current = obj_start;

for (int i = 0; i < cache->objects_per_page - 1; i++) {

struct slub_object *obj = (struct slub_object *)current;

obj->next = (struct slub_object *)((char *)current + cache->size);

current = obj->next;

}

### 4.2 地址转换机制

**虚拟地址与物理页转换**：


void *page2kva(struct Page *page)    // 页到虚拟地址

struct Page *kva2page(void *kva)    // 虚拟地址到页


实现物理页与内核虚拟地址空间的双向转换，支持SLUB与底层页分配器的无缝集成。

### 4.3 缓存选择策略

预定义对象大小序列：8, 16, 32, 64, 128, 256, 512, 1024, 2048字节，覆盖常见内核对象大小需求，在内存使用效率和内部碎片之间取得平衡[1](@ref)。

## 5. 性能优化设计

### 5.1 内存对齐优化

默认采用8字节对齐，确保不同架构下的内存访问效率。对象起始地址自动对齐到合适边界，减少非对齐访问的性能损失。

### 5.2 分配路径优化

- **快速路径**：直接从部分空闲页面的freelist分配
- **慢速路径**：需要分配新页面时的处理
- **大对象直通**：避免对小缓存的不必要开销

### 5.3 统计与监控

每个缓存维护详细统计信息，包括：
- 页面使用情况（部分空闲/完全占用）
- 对象分配数量
- 内存使用效率
支持运行时状态监控和调试。

## 6. 算法复杂度分析

| 操作类型 | 时间复杂度 | 空间复杂度 | 说明 |
|---------|-----------|-----------|------|
| 分配小对象 | O(1) | O(1) | 直接操作freelist |
| 释放小对象 | O(1) | O(1) | 直接加入freelist |
| 缓存查找 | O(1) | O(1) | 固定大小缓存数组 |
| 页面分配 | O(1) | O(1) | 调用底层页分配器 |

## 7. 测试验证策略

### 7.1 单元测试覆盖

**基础功能测试**：
- 不同大小内存分配释放
- 边界条件处理（零大小、超大内存）
- 内存内容正确性验证

**压力测试**：
- 大量小对象分配释放
- 内存重用验证
- 长时间运行稳定性

### 7.2 集成测试场景

**多尺寸混合测试**：
验证不同对象大小缓存的协同工作，确保系统在复杂使用场景下的稳定性。

**性能基准测试**：
对比传统内存分配算法的性能表现，验证SLUB在高并发场景下的优势[2](@ref)。